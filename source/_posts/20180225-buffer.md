---
title: Nodejs Buffer
date: 2018-02-25 15:53:08
tags: nodejs
---

1. Buffer 用于处理二进制数据流
1. 实例类似整数数组，大小固定
1. C++ 代码在 V8 堆外分配物理内存

# buffer 常用 API

## Buffer.alloc(size[, fill[, encoding]])

分配一个 size 字节大小的 Buffer 对象，如果 fill 没有规定，则会自动用 0 来填充。

```js
const buf = Buffer.alloc(5);

// Prints: <Buffer 00 00 00 00 00>
console.log(buf);
```

如果 fill 规定了，则分配 Buffer 的时候会调用 `buf.fill(fill)` 来初始化

```js
const buf = Buffer.alloc(5, 'a');

// Prints: <Buffer 61 61 61 61 61>
console.log(buf);
```

如果 fill 和 encoding 都规定了，则在分配 Buffer 的时候会调用 `buf.fill(fill, encoding)`

```js
const buf = Buffer.alloc(11, 'aGVsbG8gd29ybGQ=', 'base64');

// Prints: <Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>
console.log(buf);
```

调用 `Buffer.alloc()` 显著地比 `Buffer.allocUnsafe()` 要慢，但是能确保新创建的 Buffer 实例不包含敏感数据。

如果 size 不是数字的话，则会报错。

## Buffer.allocUnsafe(size)

通过 `Buffer.allocUnsafe()` 创建一个没有初始化的 Buffer 实例，这个 Buffer 所包含的内容是未知的，而且可能包含敏感信息。

```js
const buf = Buffer.allocUnsafe(10);

// Prints: (contents may vary): <Buffer a0 8b 28 3f 01 00 00 00 50 32>
console.log(buf);
```

## Buffer.byteLength()

返回字符串的字节长度

```js
console.log(Buffer.byteLength('haha')); // 4
console.log(Buffer.byteLength('哈哈')); // 6
```

## Buffer.isBuffer(obj)

判断 obj 是否为buffer

```js
console.log(Buffer.isBuffer({})) // false
console.log(Buffer.isBuffer(Buffer.from([1, 2, 3])));
```

## Buffer.concat(list[, totalLength])

返回一个合并 list 中所有的 Buffer 实例的新 Buffer 实例。

如果没有 totalLength 的话，它将从 list 中的 Buffer 实例计算得出，

## buf.length

## buf.toString()

## buf.fill()

## buf.equals()

## buf.indexOf()

## buf.copy()
